(** Representation of preterms *)

(**{1 Syntax} *)

type tag = string
type tag_set
type +'a tag_map

module TagSet : Set.S
  with type t = tag_set
   and type elt = tag

module TagMap : sig
  include Map.S
    with type 'a t = 'a tag_map
     and type key = tag

  val of_bindings : (tag * 'a) list -> 'a t
end

type 'a binder =
  | B  of string * 'a

type level = int

type term =
  { term_loc  : Location.t
  ; term_data : term_data
  }

and term_data =
  | Neutral of head * elims * term Lazy.t option

  | Set of level

  | Pi of term * term binder
  | Lam of term binder

  | QuotType  of term * term
  | QuotIntro of term

  | Sigma of term * term binder
  | Pair of term * term

  | Nat
  | Zero
  | Succ of term

  | TagType of tag_set
  | Tag of tag

  | TyEq of term * term
  | TmEq of { tm1 : term; ty1 : term; tm2 : term; ty2 : term }

  (* proof constructors *)
  | Subst of { ty_s : term
             ; ty_t : term binder
             ; tm_x : term
             ; tm_y : term
             ; tm_e : term
             }
  | Refl
  | Coh of term
  | Funext of term binder binder binder
  | SameClass of term

  (* placeholder for an erased proof term; only generated during
     reification. *)
  | Irrel

and head =
  { head_loc  : Location.t
  ; head_data : head_data
  }

and head_data =
  | Bound  of int
  | Free_local of string
  | Free_global of string
  | Coerce of { coercee  : term
              ; src_type : term
              ; tgt_type : term
              ; eq_proof : term
              }

and elims =
  { elims_loc  : Location.t
  ; elims_data : elims_data
  }

and elims_data =
  | Nil
  | App      of elims * term
  | Project  of elims * [`fst | `snd]
  | ElimNat  of elims * term binder * term * term binder binder
  | ElimQ    of elims * term binder * term binder * term binder binder binder
  | ElimTag  of elims * term binder * term tag_map

(**{2 Terms with generated locations}

   This function is for building terms that are
    generated by the system and so cannot be assigned a location in the
    user's source code. *)

(** [mk_term term_data] constructs a {!term} with [term_data] and
    {!Location.generated}. *)
val mk_term : term_data -> term

(** [mk_head head_data] constructs a {!head} with [head_data] and
    {!Location.generated}. *)
val mk_head : head_data -> head

(** [mk_elim elims_data] constructs an {!elims} with [elims_data] and
    {!Location.generated}. *)
val mk_elim : elims_data -> elims

(**{2 Location information} *)

val location_of_neutral : head -> elims -> Location.t

val location_of_term : term -> Location.t

(**{2 Alpha Equality} *)

val alpha_eq : term -> term -> bool

(**{2 Binder and Scope handling} *)

module type EXTENDABLE_CONTEXT = sig
  type t

  type ty

  type tm

  val extend : string -> ty -> t -> string * t

  val mk_free : string -> ty -> tm
end

module Scoping : sig
  val bind : string option -> term -> term binder

  val bind2 : string option -> string option -> term -> term binder binder

  val bind3 : string option -> string option -> string option -> term -> term binder binder binder

  module Close (Ctxt : EXTENDABLE_CONTEXT) : sig
    val close :
      Ctxt.ty ->
      term binder ->
      Ctxt.t ->
      Ctxt.tm * term * Ctxt.t

    val close2 :
      Ctxt.ty ->
      (Ctxt.tm -> Ctxt.ty) ->
      term binder binder ->
      Ctxt.t ->
      Ctxt.tm * Ctxt.tm * term * Ctxt.t

    val close3 :
      Ctxt.ty ->
      (Ctxt.tm -> Ctxt.ty) ->
      (Ctxt.tm -> Ctxt.tm -> Ctxt.ty) ->
      term binder binder binder ->
      Ctxt.t ->
      Ctxt.tm * Ctxt.tm * Ctxt.tm * term * Ctxt.t
  end
end
